<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
<title>LAN Drawing Board (Instant Sync)</title>

<style>
  html, body {
    margin: 0; padding: 0; overflow: hidden;
    font-family: Arial, sans-serif;
    background: #f0f0f0;
    user-select: none;
  }
  #canvasContainer {
    position: absolute;
    top: 0; left: 0; right: 0; bottom: 80px;
    background: #fff;
    overflow: hidden;
  }
  canvas {
    display: block;
    transform-origin: 0 0;
    image-rendering: pixelated;
    background: #fff;
  }
  #toolbar {
    position: fixed;
    bottom: 0; left: 0; right: 0;
    height: 80px;
    background: #fff;
    border-top: 1px solid #ccc;
    display: flex;
    justify-content: center;
    align-items: center;
    gap: 20px;
    padding: 6px;
  }
  .toolButton {
    padding: 10px 18px;
    border-radius: 6px;
    border: 1px solid #aaa;
    cursor: pointer;
    user-select: none;
  }
  .toolButton.active {
    background: #ddd;
  }
  #paletteContainer {
    display: flex;
    gap: 6px;
  }
  .color {
    width: 26px;
    height: 26px;
    border-radius: 4px;
    border: 2px solid transparent;
    cursor: pointer;
    box-sizing: border-box;
  }
  .color.active {
    border-color: black;
  }
  #brushSize {
    width: 200px;
  }
</style>
</head>
<body>

<div id="canvasContainer">
  <canvas id="canvas" width="5000" height="4000" style="border:4px solid black;"></canvas>
</div>

<div id="toolbar">
  <div id="paletteContainer"></div>
  <div>
    Size:
    <input type="range" id="brushSize" min="2" max="30" value="6">
  </div>

  <div id="pencilBtn" class="toolButton active">Pencil</div>
  <div id="panBtn" class="toolButton">Pan</div>
  <div id="eraserBtn" class="toolButton">Eraser</div>
</div>

<script>
/* CONFIG */
const FIREBASE_DB_URL = "https://drawing-ce2f6-default-rtdb.firebaseio.com";

const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");
const brushSizeEl = document.getElementById("brushSize");
const paletteContainer = document.getElementById("paletteContainer");
let currentTool = "pencil";

const pencilBtn = document.getElementById("pencilBtn");
const panBtn = document.getElementById("panBtn");
const eraserBtn = document.getElementById("eraserBtn");
eraserBtn.onclick = () => switchTool("eraser");

pencilBtn.onclick = () => switchTool("pencil");
panBtn.onclick = () => switchTool("pan");

function switchTool(t) {
  currentTool = t;
  pencilBtn.classList.toggle("active", t === "pencil");
  panBtn.classList.toggle("active", t === "pan");
  eraserBtn.classList.toggle("active", t === "eraser");
}

/* PALETTE */
const colors = [
  "#6D001A","#BE0039","#FF4500","#FFA800","#FFD635","#FFF8B8","#00A368","#00CC78",
  "#7EED56","#00756F","#009EAA","#00CCC0","#2450A4","#3690EA","#51E9F4","#493AC1",
  "#6A5CFF","#811E9F","#B44AC0","#FF3881","#FF99AA","#6D482F","#9C6926","#000000",
  "#898D90","#D4D7D9","#FFFFFF"
];

let currentColor = colors[0];
function drawPalette() {
  paletteContainer.innerHTML = "";
  colors.forEach(c => {
    const div = document.createElement("div");
    div.className = "color" + (c === currentColor ? " active" : "");
    div.style.backgroundColor = c;
    div.onclick = () => {
      currentColor = c;
      document.querySelectorAll(".color").forEach(el => el.classList.remove("active"));
      div.classList.add("active");
    };
    paletteContainer.appendChild(div);
  });
}
drawPalette();

/* PAN + ZOOM */
let scale = 1;
let tx = 0, ty = 0;

function updateTransform() {
  canvas.style.transform = `translate(${tx}px, ${ty}px) scale(${scale})`;
}
updateTransform();

let isPanning = false;
let panStartX = 0, panStartY = 0, lastTx = 0, lastTy = 0;

canvas.addEventListener("mousedown", e => {
  if (currentTool === "pan") {
    isPanning = true;
    panStartX = e.clientX;
    panStartY = e.clientY;
    lastTx = tx;
    lastTy = ty;
  }
});
window.addEventListener("mouseup", () => isPanning = false);
window.addEventListener("mousemove", e => {
  if (isPanning) {
    tx = lastTx + (e.clientX - panStartX);
    ty = lastTy + (e.clientY - panStartY);
    updateTransform();
  }
});

canvas.addEventListener("wheel", e => {
  e.preventDefault();
  const rect = canvas.getBoundingClientRect();
  const mx = e.clientX - rect.left;
  const my = e.clientY - rect.top;

  const factor = e.deltaY > 0 ? 0.9 : 1.1;
  const newScale = Math.min(Math.max(0.15, scale * factor)), 12);

  tx = mx - (mx - tx) * (newScale / scale);
  ty = my - (my - ty) * (newScale / scale);
  scale = newScale;

  updateTransform();
}, { passive: false });

/* DRAWING (NO CIRCLES — RAW PIXELS) */
let drawing = false;

canvas.addEventListener("mousedown", e => {
  if (currentTool !== "pencil") return;
  if (e.button !== 0) return;
  drawing = true;
  drawAtEvent(e);
});
window.addEventListener("mouseup", () => drawing = false);
canvas.addEventListener("mousemove", e => {
  if (drawing && currentTool === "pencil") drawAtEvent(e);
});

function drawAtEvent(e) {
  const rect = canvas.getBoundingClientRect();
  const x = Math.floor((e.clientX - rect.left) / scale);
  const y = Math.floor((e.clientY - rect.top) / scale);
  const size = parseInt(brushSizeEl.value);

  drawPixelStroke(x, y, size, currentTool === "eraser" ? "#FFFFFF" : currentColor);
  sendStroke(x, y, size, currentTool === "eraser" ? "#FFFFFF" : currentColor);
}

function drawPixelStroke(cx, cy, size, color) {
  ctx.fillStyle = color;
  ctx.fillRect(cx - size/2, cy - size/2, size, size);
}

/* INSTANT SYNC — LONGPOLL STREAM */
async function sendStroke(x, y, size, color) {
  fetch(`${FIREBASE_DB_URL}/draws.json`, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ x, y, size, color, time: Date.now() })
  }).catch(()=>{});
}

async function startRealtime() {
  const url = `${FIREBASE_DB_URL}/draws.json?orderBy=\"time\"&limitToLast=1`;

  while (true) {
    try {
      const res = await fetch(url);
      const data = await res.json();
      if (data) {
        const d = Object.values(data)[0];
        drawPixelStroke(d.x, d.y, d.size, d.color);
      }
    } catch{}
    await new Promise(r => setTimeout(r, 100));
  }
}
startRealtime();
</script>
</body>
</html>
