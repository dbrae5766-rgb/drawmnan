<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>r/Place 2022 Clone</title>
<style>
    html, body {margin:0;padding:0;overflow:hidden;font-family:Arial,sans-serif;}
    #toolbar {position:fixed;top:0;left:0;right:0;background:white;padding:8px;box-shadow:0 2px 5px rgba(0,0,0,0.1);z-index:1000;display:flex;gap:10px;align-items:center;flex-wrap:wrap;}
    .color-btn {width:25px;height:25px;border:1px solid #ccc;cursor:pointer;border-radius:3px;transition:transform 0.1s;}
    .color-btn.active {border:2px solid #333;}
    .tool-btn {padding:6px 10px;cursor:pointer;border:1px solid #ddd;border-radius:5px;font-size:14px;}
    .tool-btn.active {background:#4CAF50;color:white;border-color:#4CAF50;}
    #canvasContainer {position:absolute;top:50px;left:0;right:0;bottom:0;overflow:hidden;background:#eee;}
    #canvas {background:white;cursor:crosshair;display:block;transform-origin:0 0;}
    #zoomInfo {position:fixed;bottom:10px;right:10px;background:rgba(255,255,255,0.9);padding:6px 10px;border-radius:5px;font-size:12px;}
    .status {margin-left:auto;padding:4px 8px;border-radius:4px;font-size:12px;background:#e8f5e9;color:#2e7d32;}
    .status.error {background:#ffebee;color:#c62828;}
    #cooldown {margin-left:10px;font-size:12px;}
    .cursor {position:absolute;width:10px;height:10px;border-radius:50%;border:2px solid #333;pointer-events:none;z-index:999;transform:translate(-50%,-50%);}
</style>
</head>
<body>
<div id="toolbar">
    <div class="tool-section">
        <button id="drawBtn" class="tool-btn active">‚úèÔ∏è Draw</button>
        <button id="panBtn" class="tool-btn">üëã Pan</button>
    </div>
    <div class="color-palette" id="colorPalette"></div>
    <div class="status" id="status">Connecting...</div>
    <div id="cooldown"></div>
</div>
<div id="canvasContainer">
    <canvas id="canvas" width="5000" height="5000"></canvas>
</div>
<div id="zoomInfo">Zoom: 100%</div>
<script type="module">
const FIREBASE_DB_URL = 'https://drawing-ce2f6-default-rtdb.firebaseio.com';

const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
const colorPalette = document.getElementById('colorPalette');
const status = document.getElementById('status');
const cooldownEl = document.getElementById('cooldown');

const colors = [
    '#FF0000','#00FF00','#0000FF','#FFFF00','#FF00FF','#00FFFF','#FFA500','#800080',
    '#FFC0CB','#A52A2A','#808080','#000000','#FFFFFF','#008000','#000080','#800000'
];

let currentColor = '#000000';
let isDrawing = false;
let isPanning = false;
let currentTool = 'draw';
let scale = 1;
let translateX = 0;
let translateY = 0;
let lastX = 0;
let lastY = 0;
let panStartX = 0;
let panStartY = 0;

let sessionId = Date.now()+'-'+Math.random().toString(36).substr(2,9);
let lastPlaced = 0;
let isAdmin = false;
let placeInterval = 300000; // 5 min default
const adminIP = '69.170.112.226';

const tileSize = 50; // 50x50 tiles for rendering
const boardWidth = 5000;
const boardHeight = 5000;
const cols = Math.ceil(boardWidth/tileSize);
const rows = Math.ceil(boardHeight/tileSize);

let tiles = [];
for(let r=0;r<rows;r++){
    tiles[r]=[];
    for(let c=0;c<cols;c++){
        tiles[r][c]=ctx.createImageData(tileSize,tileSize);
    }
}

// Initialize Firebase-like fetch functions
const pixelsRef = FIREBASE_DB_URL+'/pixels.json';
const cursorsRef = FIREBASE_DB_URL+'/cursors.json';

async function checkAdmin() {
    try {
        const resp = await fetch('https://api.ipify.org?format=json');
        const data = await resp.json();
        if(data.ip===adminIP){
            isAdmin=true;
            placeInterval=1000;
            status.textContent='üëë Admin Mode';
        }
    } catch(err){console.log('IP check skipped');}
}

checkAdmin();

// Color palette buttons
colors.forEach(color=>{
    const btn=document.createElement('div');
    btn.className='color-btn';
    btn.style.backgroundColor=color;
    if(color===currentColor) btn.classList.add('active');
    btn.addEventListener('click',()=>{
        currentColor=color;
        document.querySelectorAll('.color-btn').forEach(b=>b.classList.remove('active'));
        btn.classList.add('active');
    });
    colorPalette.appendChild(btn);
});

// Tool buttons
document.getElementById('drawBtn').addEventListener('click',()=>{
    currentTool='draw';
    canvas.style.cursor='crosshair';
});
document.getElementById('panBtn').addEventListener('click',()=>{
    currentTool='pan';
    canvas.style.cursor='grab';
});

// Transform update
function updateTransform(){
    canvas.style.transform=`translate(${translateX}px,${translateY}px) scale(${scale})`;
    document.getElementById('zoomInfo').textContent=`Zoom: ${Math.round(scale*100)}%`;
}
function getCanvasCoords(x,y){
    const rect=canvas.getBoundingClientRect();
    return {
        x: Math.floor((x-rect.left)/scale),
        y: Math.floor((y-rect.top)/scale)
    };
}

// Draw pixel
function drawPixel(x,y,color){
    ctx.fillStyle=color;
    ctx.fillRect(x,y,1,1);
}

// Fetch all pixels and draw
async function loadAllPixels(){
    try{
        const resp=await fetch(pixelsRef);
        const data=await resp.json();
        if(data){
            Object.entries(data).forEach(([key,pixel])=>{
                drawPixel(pixel.x,pixel.y,pixel.color);
            });
        }
        status.textContent='üü¢ Live';
    }catch(err){
        console.error(err);
        status.textContent='‚ö†Ô∏è Load error';
        status.classList.add('error');
    }
}

loadAllPixels();

// Handle mouse/touch
canvas.addEventListener('mousedown',e=>{
    if(currentTool==='draw') isDrawing=true;
    else if(currentTool==='pan'){
        isPanning=true;
        panStartX=e.clientX-translateX;
        panStartY=e.clientY-translateY;
        canvas.style.cursor='grabbing';
    }
    const coords=getCanvasCoords(e.clientX,e.clientY);
    lastX=coords.x;
    lastY=coords.y;
});
canvas.addEventListener('mousemove',e=>{
    if(isDrawing && currentTool==='draw'){
        const coords=getCanvasCoords(e.clientX,e.clientY);
        lastX=coords.x;
        lastY=coords.y;
    } else if(isPanning){
        translateX=e.clientX-panStartX;
        translateY=e.clientY-panStartY;
        updateTransform();
    }
});
canvas.addEventListener('mouseup',async e=>{
    if(isDrawing){
        const now=Date.now();
        if(now-lastPlaced>=placeInterval){
            const coords=getCanvasCoords(e.clientX,e.clientY);
            drawPixel(coords.x,coords.y,currentColor);
            try{
                await fetch(pixelsRef+'/'+coords.x+'_'+coords.y+'.json',{
                    method:'PUT',
                    headers:{'Content-Type':'application/json'},
                    body:JSON.stringify({x:coords.x,y:coords.y,color:currentColor,timestamp:Date.now()})
                });
                lastPlaced=Date.now();
            }catch(err){console.error(err);}
        }
    }
    isDrawing=false;
    isPanning=false;
    canvas.style.cursor=currentTool==='draw'?'crosshair':'grab';
});

// Zoom
canvas.addEventListener('wheel',e=>{
    e.preventDefault();
    const rect=canvas.getBoundingClientRect();
    const mx=e.clientX-rect.left;
    const my=e.clientY-rect.top;
    const delta=e.deltaY>0?0.9:1.1;
    const newScale=Math.min(Math.max(0.1,scale*delta),10);
    const change=newScale/scale;
    translateX=mx-(mx-translateX)*change;
    translateY=my-(my-translateY)*change;
    scale=newScale;
    updateTransform();
},{passive:false});

// Cooldown display
setInterval(()=>{
    if(lastPlaced===0) cooldownEl.textContent='Ready';
    else{
        const remaining=Math.max(0,placeInterval-(Date.now()-lastPlaced));
        const sec=Math.ceil(remaining/1000);
        cooldownEl.textContent=isAdmin?'Admin cooldown: '+sec+'s':'Cooldown: '+sec+'s';
    }
},1000);

// Realtime sync
setInterval(async()=>{
    try{
        const resp=await fetch(pixelsRef);
        const data=await resp.json();
        if(data){
            Object.entries(data).forEach(([key,pixel])=>{
                drawPixel(pixel.x,pixel.y,pixel.color);
            });
        }
    }catch(err){}
},3000);

</script>
</body>
</html>
