<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>Collaborative Drawing Canvas</title>
<style>
* {
margin: 0;
padding: 0;
box-sizing: border-box;
}
body {
font-family: Arial, sans-serif;
overflow: hidden;
background: #f0f0f0;
touch-action: none;
}
#toolbar {
position: fixed;
top: 0;
left: 0;
right: 0;
background: white;
padding: 10px;
box-shadow: 0 2px 5px rgba(0,0,0,0.1);
z-index: 1000;
display: flex;
gap: 10px;
align-items: center;
flex-wrap: wrap;
}
.tool-section {
display: flex;
gap: 5px;
align-items: center;
}
.color-palette {
display: grid;
grid-template-columns: repeat(8, 1fr);
gap: 4px;
}
.color-btn {
width: 30px;
height: 30px;
border: 2px solid #ddd;
cursor: pointer;
border-radius: 5px;
transition: transform 0.1s;
}
.color-btn:hover {
transform: scale(1.1);
}
.color-btn.active {
border: 3px solid #333;
box-shadow: 0 0 5px rgba(0,0,0,0.3);
}
.tool-btn {
padding: 8px 12px;
cursor: pointer;
border: 2px solid #ddd;
background: white;
border-radius: 5px;
font-size: 14px;
transition: all 0.2s;
}
.tool-btn.active {
background: #4CAF50;
color: white;
border-color: #4CAF50;
}
.tool-btn:hover:not(:disabled) {
background: #f0f0f0;
}
.tool-btn.active:hover {
background: #45a049;
}
.tool-btn:disabled {
opacity: 0.5;
cursor: not-allowed;
}
.size-control {
display: flex;
align-items: center;
gap: 8px;
}
#sizeSlider {
width: 80px;
transition: width 0.3s ease;
}
#sizeSlider.admin-mode {
width: 160px;
}
#canvasContainer {
position: absolute;
top: 60px;
left: 0;
right: 0;
bottom: 0;
overflow: hidden;
background: #e0e0e0;
}
#canvas {
display: block;
background: white;
cursor: crosshair;
transform-origin: 0 0;
}
#canvas.pan-mode {
cursor: grab;
}
#canvas.pan-mode:active {
cursor: grabbing;
}
#zoomInfo {
position: fixed;
bottom: 10px;
right: 10px;
background: rgba(255,255,255,0.9);
padding: 8px 12px;
border-radius: 5px;
font-size: 12px;
z-index: 1000;
}
.cursor {
position: absolute;
width: 12px;
height: 12px;
border-radius: 50%;
border: 2px solid #333;
pointer-events: none;
transition: transform 0.1s ease;
z-index: 999;
transform: translate(-50%, -50%);
}
.cursor-label {
position: absolute;
top: -25px;
left: 15px;
background: rgba(0,0,0,0.7);
color: white;
padding: 2px 6px;
border-radius: 3px;
font-size: 10px;
white-space: nowrap;
}
.status {
margin-left: auto;
padding: 5px 10px;
background: #e8f5e9;
border-radius: 5px;
font-size: 12px;
color: #2e7d32;
}
.status.error {
background: #ffebee;
color: #c62828;
}

@media (max-width: 768px) {
#toolbar {
padding: 8px;
gap: 8px;
}
.color-btn {
width: 25px;
height: 25px;
}
.color-palette {
grid-template-columns: repeat(8, 1fr);
}
.tool-btn {
padding: 6px 10px;
font-size: 12px;
}
#sizeSlider {
width: 60px;
}
.size-control label {
font-size: 12px;
}
#sizeValue {
font-size: 12px;
}
#canvasContainer {
top: 110px;
}
}
</style>
</head>
<body>
<div id="toolbar">
<div class="tool-section">
<button id="drawBtn" class="tool-btn active">‚úèÔ∏è Draw</button>
<button id="panBtn" class="tool-btn">üëã Pan</button>
</div>
<div class="color-palette" id="colorPalette"></div>
<div class="size-control">
<label for="sizeSlider">Size:</label>
<input type="range" id="sizeSlider" min="1" max="20" value="2">
<span id="sizeValue">2</span>
</div>
<button id="undoBtn" class="tool-btn">‚Ü∂ Undo</button>
<button id="redoBtn" class="tool-btn">‚Ü∑ Redo</button>
<div class="status" id="status">Connecting...</div>
</div>
<div id="canvasContainer">
<canvas id="canvas" width="3000" height="2000"></canvas>
</div>
<div id="zoomInfo">Zoom: 100%</div>

<script type="module">
const FIREBASE_DB_URL = 'https://drawing-ce2f6-default-rtdb.firebaseio.com';

const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
const colorPalette = document.getElementById('colorPalette');
const sizeSlider = document.getElementById('sizeSlider');
const sizeValue = document.getElementById('sizeValue');
const undoBtn = document.getElementById('undoBtn');
const redoBtn = document.getElementById('redoBtn');
const drawBtn = document.getElementById('drawBtn');
const panBtn = document.getElementById('panBtn');
const zoomInfo = document.getElementById('zoomInfo');
const status = document.getElementById('status');

const colors = [
'#FF0000', '#00FF00', '#0000FF', '#FFFF00',
'#FF00FF', '#00FFFF', '#FFA500', '#800080',
'#FFC0CB', '#A52A2A', '#808080', '#000000',
'#FFFFFF', '#008000', '#000080', '#800000'
];

let currentColor = '#000000';
let brushSize = 2;
let isDrawing = false;
let isPanning = false;
let currentTool = 'draw';
let lastX = 0;
let lastY = 0;
let history = [];
let historyStep = -1;
let currentStroke = [];

let scale = 1;
let translateX = 0;
let translateY = 0;
let panStartX = 0;
let panStartY = 0;
let initialPinchDistance = 0;
let lastScale = 1;
let isAdmin = false;
let maxBrushSize = 20;

// Cursor tracking
let userCursors = new Map();
let lastCursorUpdate = 0;
let isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);

// Firebase connection
const linesRef = FIREBASE_DB_URL + '/lines.json';
const cursorsRef = FIREBASE_DB_URL + '/cursors.json';
const presenceRef = FIREBASE_DB_URL + '/presence.json';
let isConnected = false;
let lineBuffer = [];
let lastLineId = 0;
let sessionId = Date.now() + '-' + Math.random().toString(36).substr(2, 9);
let syncInterval = null;
let listenInterval = null;
let presenceInterval = null;
let inactiveCheckInterval = null;
let processedLineIds = new Set();

// Check if user is admin
async function checkAdminStatus() {
try {
const response = await fetch('https://api.ipify.org?format=json');
const data = await response.json();
if (data.ip === '69.170.112.226') {
isAdmin = true;
maxBrushSize = 1000;
sizeSlider.max = 1000;
sizeSlider.classList.add('admin-mode');
status.textContent = 'üëë Admin Mode';
status.style.background = '#fff3e0';
status.style.color = '#e65100';
}
} catch (error) {
console.log('IP check skipped');
}
}

// Presence system - update every 5 seconds
function startPresenceUpdates() {
updatePresence();
presenceInterval = setInterval(updatePresence, 5000);
}

async function updatePresence() {
if (isConnected) {
try {
await fetch(`${presenceRef}/${sessionId}.json`, {
method: 'PUT',
headers: { 'Content-Type': 'application/json' },
body: JSON.stringify({
timestamp: Date.now(),
active: true
})
});
} catch (error) {
console.error('Presence update error:', error);
}
}
}

// Check for inactive users every 30 seconds
function startInactiveCheck() {
inactiveCheckInterval = setInterval(checkInactiveUsers, 30000);
}

async function checkInactiveUsers() {
if (!isConnected) return;
try {
const response = await fetch(presenceRef);
const presenceData = await response.json();
const now = Date.now();
const tenMinutes = 10 * 60 * 1000;

if (!presenceData) {
await clearAllData();
return;
}

const activeSessions = Object.entries(presenceData).filter(([sid, data]) => {
return now - data.timestamp < tenMinutes;
});

if (activeSessions.length === 0) {
await clearAllData();
}
} catch (error) {
console.error('Inactive check error:', error);
}
}

async function clearAllData() {
try {
await fetch(linesRef, { method: 'DELETE' });
await fetch(cursorsRef, { method: 'DELETE' });
await fetch(presenceRef, { method: 'DELETE' });
ctx.clearRect(0, 0, canvas.width, canvas.height);
history = [];
historyStep = -1;
processedLineIds.clear();
updateUndoRedoButtons();
console.log('Canvas cleared due to inactivity');
} catch (error) {
console.error('Clear all data error:', error);
}
}

// Initialize Firebase connection
async function initFirebase() {
try {
const response = await fetch(linesRef);
if (response.ok) {
isConnected = true;
status.textContent = 'üü¢ Connected';
status.classList.remove('error');
await checkInactiveUsers();
loadFromFirebase();
startRealtimeListener();
startPresenceUpdates();
startInactiveCheck();
} else {
status.textContent = '‚ö†Ô∏è Connection Failed';
status.classList.add('error');
}
} catch (error) {
console.error('Firebase init error:', error);
status.textContent = '‚ö†Ô∏è Connection Error';
status.classList.add('error');
}
}

async function loadFromFirebase() {
if (!isConnected) return;
try {
const response = await fetch(linesRef);
const data = await response.json();
if (data) {
const lines = Object.entries(data).map(([id, line]) => ({
...line,
id: id
})).sort((a, b) => a.timestamp - b.timestamp);

lines.forEach(line => {
drawLine(line.x1, line.y1, line.x2, line.y2, line.color, line.size);
processedLineIds.add(line.id);
});

if (lines.length > 0) {
lastLineId = Math.max(...lines.map(l => parseInt(l.id.split('-')[0]) || 0));
}
}
} catch (error) {
console.error('Load error:', error);
}
}

// Send lines in batches every 50ms for ultra-fast real-time drawing
function startBatchSync() {
if (syncInterval) return;
syncInterval = setInterval(async () => {
if (lineBuffer.length > 0 && isConnected) {
const batch = [...lineBuffer];
lineBuffer = [];

try {
const updates = {};
batch.forEach(line => {
const id = `${lastLineId++}-${sessionId}`;
updates[id] = line;
processedLineIds.add(id);
});

await fetch(linesRef, {
method: 'PATCH',
headers: { 'Content-Type': 'application/json' },
body: JSON.stringify(updates)
});

status.textContent = 'üü¢ Live';
status.classList.remove('error');
} catch (error) {
console.error('Batch sync error:', error);
status.textContent = '‚ö†Ô∏è Sync Failed';
status.classList.add('error');
lineBuffer = [...batch, ...lineBuffer];
}
}
}, 50);
}

// Listen for new lines every 50ms for instant updates
function startRealtimeListener() {
listenInterval = setInterval(async () => {
if (isConnected) {
try {
const response = await fetch(linesRef);
const data = await response.json();

if (data) {
const newLines = Object.entries(data)
.map(([id, line]) => ({ ...line, id }))
.filter(line => line.sessionId !== sessionId && !processedLineIds.has(line.id))
.sort((a, b) => a.timestamp - b.timestamp);

newLines.forEach(line => {
drawLine(line.x1, line.y1, line.x2, line.y2, line.color, line.size);
processedLineIds.add(line.id);
});
}

const cursorsResponse = await fetch(cursorsRef);
const cursorsData = await cursorsResponse.json();
if (cursorsData) {
updateOtherCursors(cursorsData);
}
} catch (error) {
console.error('Listener error:', error);
}
}
}, 50);
}

// Color buttons
colors.forEach(color => {
const btn = document.createElement('div');
btn.className = 'color-btn';
btn.style.backgroundColor = color;
if (color === '#FFFFFF') btn.style.border = '2px solid #333';
if (color === currentColor) btn.classList.add('active');
btn.addEventListener('click', () => {
currentColor = color;
document.querySelectorAll('.color-btn').forEach(b => b.classList.remove('active'));
btn.classList.add('active');
});
colorPalette.appendChild(btn);
});

drawBtn.addEventListener('click', () => {
currentTool = 'draw';
drawBtn.classList.add('active');
panBtn.classList.remove('active');
canvas.classList.remove('pan-mode');
});

panBtn.addEventListener('click', () => {
currentTool = 'pan';
panBtn.classList.add('active');
drawBtn.classList.remove('active');
canvas.classList.add('pan-mode');
});

sizeSlider.addEventListener('input', (e) => {
brushSize = parseInt(e.target.value);
sizeValue.textContent = brushSize;
            
if (isAdmin && brushSize > 100) {
sizeValue.style.fontWeight = 'bold';
sizeValue.style.color = '#e65100';
} else {
sizeValue.style.fontWeight = 'normal';
sizeValue.style.color = 'inherit';
}
});

function updateTransform() {
canvas.style.transform = `translate(${translateX}px, ${translateY}px) scale(${scale})`;
zoomInfo.textContent = `Zoom: ${Math.round(scale * 100)}%`;
}

function getCanvasCoords(clientX, clientY) {
const rect = canvas.getBoundingClientRect();
return {
x: (clientX - rect.left) / scale,
y: (clientY - rect.top) / scale
};
}

function startDrawing(e) {
if (currentTool === 'draw') {
isDrawing = true;
const coords = getCanvasCoords(e.clientX, e.clientY);
lastX = coords.x;
lastY = coords.y;
currentStroke = [];
                
if (isMobile) {
updateCursorPosition(coords.x, coords.y, true);
}
} else if (currentTool === 'pan') {
isPanning = true;
panStartX = e.clientX - translateX;
panStartY = e.clientY - translateY;
}
}

function draw(e) {
if (currentTool === 'draw' && isDrawing) {
const coords = getCanvasCoords(e.clientX, e.clientY);

drawLine(lastX, lastY, coords.x, coords.y, currentColor, brushSize);

const line = {
x1: lastX,
y1: lastY,
x2: coords.x,
y2: coords.y,
color: currentColor,
size: brushSize,
timestamp: Date.now(),
sessionId: sessionId
};
lineBuffer.push(line);
currentStroke.push(line);

lastX = coords.x;
lastY = coords.y;
} else if (currentTool === 'pan' && isPanning) {
translateX = e.clientX - panStartX;
translateY = e.clientY - panStartY;
updateTransform();
}
}

function stopDrawing() {
if (isDrawing && currentStroke.length > 0) {
history.push([...currentStroke]);
historyStep = history.length - 1;
currentStroke = [];
updateUndoRedoButtons();
                
if (isMobile) {
updateCursorPosition(0, 0, false);
}
}
isDrawing = false;
isPanning = false;
}

function drawLine(x1, y1, x2, y2, color, size) {
ctx.strokeStyle = color;
ctx.lineWidth = size;
ctx.lineCap = 'round';
ctx.lineJoin = 'round';
ctx.beginPath();
ctx.moveTo(x1, y1);
ctx.lineTo(x2, y2);
ctx.stroke();
}

function updateUndoRedoButtons() {
undoBtn.disabled = history.length === 0;
redoBtn.disabled = true;
}

async function updateCursorPosition(x, y, visible) {
const now = Date.now();
if (now - lastCursorUpdate < 50 && visible) return;
lastCursorUpdate = now;
            
if (isConnected) {
try {
await fetch(`${cursorsRef}/${sessionId}.json`, {
method: 'PUT',
headers: { 'Content-Type': 'application/json' },
body: JSON.stringify({
x: x,
y: y,
color: currentColor,
visible: visible,
isMobile: isMobile,
timestamp: now
})
});
} catch (error) {
console.error('Cursor update error:', error);
}
}
}

function updateOtherCursors(cursorsData) {
const now = Date.now();
const activeSessions = new Set();
            
Object.entries(cursorsData).forEach(([sid, cursor]) => {
if (sid === sessionId) return;
if (now - cursor.timestamp > 3000) return;
if (!cursor.visible) return;
if (cursor.isMobile && !cursor.visible) return;
                
activeSessions.add(sid);
                
let cursorEl = userCursors.get(sid);
if (!cursorEl) {
cursorEl = document.createElement('div');
cursorEl.className = 'cursor';
cursorEl.innerHTML = `<div class="cursor-label">User</div>`;
canvas.parentElement.appendChild(cursorEl);
userCursors.set(sid, cursorEl);
}
                
const screenX = cursor.x * scale + translateX;
const screenY = cursor.y * scale + translateY;
                
cursorEl.style.left = screenX + 'px';
cursorEl.style.top = screenY + 'px';
cursorEl.style.background = cursor.color;
cursorEl.style.display = 'block';
});
            
userCursors.forEach((cursorEl, sid) => {
if (!activeSessions.has(sid)) {
cursorEl.style.display = 'none';
}
});
}

if (!isMobile) {
canvas.addEventListener('mousemove', (e) => {
if (currentTool === 'draw' && !isPanning) {
const coords = getCanvasCoords(e.clientX, e.clientY);
updateCursorPosition(coords.x, coords.y, true);
}
});
}

function undo() {
if (history.length > 0) {
history.pop();
historyStep = history.length - 1;
redrawFromHistory();
updateUndoRedoButtons();
}
}

function redrawFromHistory() {
ctx.clearRect(0, 0, canvas.width, canvas.height);
history.forEach(stroke => {
stroke.forEach(line => {
drawLine(line.x1, line.y1, line.x2, line.y2, line.color, line.size);
});
});
}

undoBtn.addEventListener('click', undo);

document.addEventListener('keydown', (e) => {
if (e.ctrlKey && e.key === 'z' && !e.shiftKey) {
e.preventDefault();
undo();
}
});

canvas.addEventListener('wheel', (e) => {
e.preventDefault();
const rect = canvas.getBoundingClientRect();
const mouseX = e.clientX - rect.left;
const mouseY = e.clientY - rect.top;
const delta = e.deltaY > 0 ? 0.9 : 1.1;
const newScale = Math.min(Math.max(0.1, scale * delta), 10);
const scaleChange = newScale / scale;
translateX = mouseX - (mouseX - translateX) * scaleChange;
translateY = mouseY - (mouseY - translateY) * scaleChange;
scale = newScale;
updateTransform();
}, { passive: false });

canvas.addEventListener('touchstart', (e) => {
e.preventDefault();
if (e.touches.length === 1 && currentTool === 'draw') {
const touch = e.touches[0];
const coords = getCanvasCoords(touch.clientX, touch.clientY);
isDrawing = true;
lastX = coords.x;
lastY = coords.y;
currentStroke = [];
} else if (e.touches.length === 1 && currentTool === 'pan') {
const touch = e.touches[0];
isPanning = true;
panStartX = touch.clientX - translateX;
panStartY = touch.clientY - translateY;
} else if (e.touches.length === 2) {
isDrawing = false;
isPanning = false;
const touch1 = e.touches[0];
const touch2 = e.touches[1];
initialPinchDistance = Math.hypot(
touch2.clientX - touch1.clientX,
touch2.clientY - touch1.clientY
);
lastScale = scale;
}
}, { passive: false });

canvas.addEventListener('touchmove', (e) => {
e.preventDefault();
if (e.touches.length === 1 && currentTool === 'draw' && isDrawing) {
const touch = e.touches[0];
const coords = getCanvasCoords(touch.clientX, touch.clientY);

drawLine(lastX, lastY, coords.x, coords.y, currentColor, brushSize);

const line = {
x1: lastX,
y1: lastY,
x2: coords.x,
y2: coords.y,
color: currentColor,
size: brushSize,
timestamp: Date.now(),
sessionId: sessionId
};
lineBuffer.push(line);
currentStroke.push(line);

updateCursorPosition(coords.x, coords.y, true);
                
lastX = coords.x;
lastY = coords.y;
} else if (e.touches.length === 1 && currentTool === 'pan' && isPanning) {
const touch = e.touches[0];
translateX = touch.clientX - panStartX;
translateY = touch.clientY - panStartY;
updateTransform();
} else if (e.touches.length === 2) {
const touch1 = e.touches[0];
const touch2 = e.touches[1];
const currentDistance = Math.hypot(
touch2.clientX - touch1.clientX,
touch2.clientY - touch1.clientY
);
const centerX = (touch1.clientX + touch2.clientX) / 2;
const centerY = (touch1.clientY + touch2.clientY) / 2;
const rect = canvas.getBoundingClientRect();
const pointX = centerX - rect.left;
const pointY = centerY - rect.top;
const newScale = Math.min(Math.max(0.1, lastScale * (currentDistance / initialPinchDistance)), 10);
const scaleChange = newScale / scale;
translateX = pointX - (pointX - translateX) * scaleChange;
translateY = pointY - (pointY - translateY) * scaleChange;
scale = newScale;
updateTransform();
}
}, { passive: false });

canvas.addEventListener('touchend', (e) => {
e.preventDefault();
if (e.touches.length === 0) {
if (isDrawing && currentStroke.length > 0) {
history.push([...currentStroke]);
historyStep = history.length - 1;
currentStroke = [];
updateUndoRedoButtons();
                    
if (isMobile) {
updateCursorPosition(0, 0, false);
}
}
isDrawing = false;
isPanning = false;
}
}, { passive: false });

canvas.addEventListener('mousedown', startDrawing);
canvas.addEventListener('mousemove', draw);
canvas.addEventListener('mouseup', stopDrawing);
canvas.addEventListener('mouseout', stopDrawing);

// Cleanup on page unload
window.addEventListener('beforeunload', async () => {
if (isConnected) {
await fetch(`${presenceRef}/${sessionId}.json`, { method: 'DELETE' });
await fetch(`${cursorsRef}/${sessionId}.json`, { method: 'DELETE' });
}
});

// Initialize
updateTransform();
updateUndoRedoButtons();
checkAdminStatus();
initFirebase();
startBatchSync();
</script>
</body>
</html>
