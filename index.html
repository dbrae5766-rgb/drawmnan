<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>Collaborative Drawing Canvas</title>
<style>
* {
margin: 0;
padding: 0;
box-sizing: border-box;
}
body {
font-family: Arial, sans-serif;
overflow: hidden;
background: #f0f0f0;
touch-action: none;
}
#toolbar {
position: fixed;
top: 0;
left: 0;
right: 0;
background: white;
padding: 10px;
box-shadow: 0 2px 5px rgba(0,0,0,0.1);
z-index: 1000;
display: flex;
gap: 10px;
align-items: center;
flex-wrap: wrap;
}
.tool-section {
display: flex;
gap: 5px;
align-items: center;
}
.color-palette {
display: grid;
grid-template-columns: repeat(8, 1fr);
gap: 4px;
}
.color-btn {
width: 30px;
height: 30px;
border: 2px solid #ddd;
cursor: pointer;
border-radius: 5px;
transition: transform 0.1s;
}
.color-btn:hover {
transform: scale(1.1);
}
.color-btn.active {
border: 3px solid #333;
box-shadow: 0 0 5px rgba(0,0,0,0.3);
}
.tool-btn {
padding: 8px 12px;
cursor: pointer;
border: 2px solid #ddd;
background: white;
border-radius: 5px;
font-size: 14px;
transition: all 0.2s;
}
.tool-btn.active {
background: #4CAF50;
color: white;
border-color: #4CAF50;
}
.tool-btn:hover:not(:disabled) {
background: #f0f0f0;
}
.tool-btn.active:hover {
background: #45a049;
}
.tool-btn:disabled {
opacity: 0.5;
cursor: not-allowed;
}
.size-control {
display: flex;
align-items: center;
gap: 8px;
}
#sizeSlider {
width: 80px;
            transition: width 0.3s ease;
        }
        #sizeSlider.admin-mode {
            width: 160px;
}
#canvasContainer {
position: absolute;
top: 60px;
left: 0;
right: 0;
bottom: 0;
overflow: hidden;
background: #e0e0e0;
}
#canvas {
display: block;
background: white;
cursor: crosshair;
transform-origin: 0 0;
}
#canvas.pan-mode {
cursor: grab;
}
#canvas.pan-mode:active {
cursor: grabbing;
}
#zoomInfo {
position: fixed;
bottom: 10px;
right: 10px;
background: rgba(255,255,255,0.9);
padding: 8px 12px;
border-radius: 5px;
font-size: 12px;
z-index: 1000;
}
        .cursor {
            position: absolute;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            border: 2px solid #333;
            pointer-events: none;
            transition: transform 0.1s ease;
            z-index: 999;
            transform: translate(-50%, -50%);
        }
        .cursor-label {
            position: absolute;
            top: -25px;
            left: 15px;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 10px;
            white-space: nowrap;
        }
.status {
margin-left: auto;
padding: 5px 10px;
background: #e8f5e9;
border-radius: 5px;
font-size: 12px;
color: #2e7d32;
}
.status.error {
background: #ffebee;
color: #c62828;
}

@media (max-width: 768px) {
#toolbar {
padding: 8px;
gap: 8px;
}
.color-btn {
width: 25px;
height: 25px;
}
.color-palette {
grid-template-columns: repeat(8, 1fr);
}
.tool-btn {
padding: 6px 10px;
font-size: 12px;
}
#sizeSlider {
width: 60px;
}
.size-control label {
font-size: 12px;
}
#sizeValue {
font-size: 12px;
}
#canvasContainer {
top: 110px;
}
}
</style>
</head>
<body>
<div id="toolbar">
<div class="tool-section">
<button id="drawBtn" class="tool-btn active">‚úèÔ∏è Draw</button>
<button id="panBtn" class="tool-btn">üëã Pan</button>
</div>
<div class="color-palette" id="colorPalette"></div>
<div class="size-control">
<label for="sizeSlider">Size:</label>
<input type="range" id="sizeSlider" min="1" max="20" value="2">
<span id="sizeValue">2</span>
</div>
<button id="undoBtn" class="tool-btn">‚Ü∂ Undo</button>
<button id="redoBtn" class="tool-btn">‚Ü∑ Redo</button>
<button id="clearBtn" class="tool-btn">üóëÔ∏è Clear</button>
<div class="status" id="status">Connecting...</div>
</div>
<div id="canvasContainer">
<canvas id="canvas" width="3000" height="2000"></canvas>
</div>
<div id="zoomInfo">Zoom: 100%</div>

<script type="module">
const FIREBASE_DB_URL = 'https://drawing-ce2f6-default-rtdb.firebaseio.com';

const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
const colorPalette = document.getElementById('colorPalette');
const sizeSlider = document.getElementById('sizeSlider');
const sizeValue = document.getElementById('sizeValue');
const clearBtn = document.getElementById('clearBtn');
const undoBtn = document.getElementById('undoBtn');
const redoBtn = document.getElementById('redoBtn');
const drawBtn = document.getElementById('drawBtn');
const panBtn = document.getElementById('panBtn');
const zoomInfo = document.getElementById('zoomInfo');
const status = document.getElementById('status');

const colors = [
'#FF0000', '#00FF00', '#0000FF', '#FFFF00',
'#FF00FF', '#00FFFF', '#FFA500', '#800080',
'#FFC0CB', '#A52A2A', '#808080', '#000000',
'#FFFFFF', '#008000', '#000080', '#800000'
];

let currentColor = '#000000';
let brushSize = 2;
let isDrawing = false;
let isPanning = false;
let currentTool = 'draw';
let lastX = 0;
let lastY = 0;
let history = [];
let historyStep = -1;
let currentStroke = [];

let scale = 1;
let translateX = 0;
let translateY = 0;
let panStartX = 0;
let panStartY = 0;
let initialPinchDistance = 0;
let lastScale = 1;
        let isAdmin = false;
        let maxBrushSize = 20;

        // Cursor tracking
        let userCursors = new Map();
        let lastCursorUpdate = 0;
        let isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);

// Firebase connection - optimized for real-time
const linesRef = FIREBASE_DB_URL + '/lines.json';
const clearRef = FIREBASE_DB_URL + '/clearSignal.json';
        const cursorsRef = FIREBASE_DB_URL + '/cursors.json';
let isConnected = false;
let lineBuffer = [];
let lastLineId = 0;
let sessionId = Date.now() + '-' + Math.random().toString(36).substr(2, 9);
let syncInterval = null;
let listenInterval = null;

        // Check if user is admin (IP: 69.170.112.226)
        async function checkAdminStatus() {
            try {
                const response = await fetch('https://api.ipify.org?format=json');
                const data = await response.json();
                if (data.ip === '69.170.112.226') {
                    isAdmin = true;
                    maxBrushSize = 1000;
                    sizeSlider.max = 1000;
                    sizeSlider.classList.add('admin-mode');
                    status.textContent = 'üëë Admin Mode';
                    status.style.background = '#fff3e0';
                    status.style.color = '#e65100';
                }
            } catch (error) {
                console.log('IP check skipped');
            }
        }

// Initialize Firebase connection
async function initFirebase() {
try {
const response = await fetch(linesRef);
if (response.ok) {
isConnected = true;
status.textContent = 'üü¢ Connected';
status.classList.remove('error');
loadFromFirebase();
startRealtimeListener();
} else {
status.textContent = '‚ö†Ô∏è Connection Failed';
status.classList.add('error');
}
} catch (error) {
console.error('Firebase init error:', error);
status.textContent = '‚ö†Ô∏è Connection Error';
status.classList.add('error');
}
}

async function loadFromFirebase() {
if (!isConnected) return;
try {
const response = await fetch(linesRef);
const data = await response.json();
if (data) {
const lines = Object.entries(data).map(([id, line]) => ({
...line,
id: id
})).sort((a, b) => a.timestamp - b.timestamp);

lines.forEach(line => {
drawLine(line.x1, line.y1, line.x2, line.y2, line.color, line.size);
});

if (lines.length > 0) {
lastLineId = Math.max(...lines.map(l => parseInt(l.id.split('-')[0]) || 0));
}
}
} catch (error) {
console.error('Load error:', error);
}
}

// Send lines in batches every 50ms for ultra-fast real-time drawing
function startBatchSync() {
if (syncInterval) return;
syncInterval = setInterval(async () => {
if (lineBuffer.length > 0 && isConnected) {
const batch = [...lineBuffer];
lineBuffer = [];

try {
// Send multiple lines at once using PATCH for speed
const updates = {};
batch.forEach(line => {
const id = `${lastLineId++}-${sessionId}`;
updates[id] = line;
});

await fetch(linesRef, {
method: 'PATCH',
headers: { 'Content-Type': 'application/json' },
body: JSON.stringify(updates)
});

status.textContent = 'üü¢ Live';
status.classList.remove('error');
} catch (error) {
console.error('Batch sync error:', error);
status.textContent = '‚ö†Ô∏è Sync Failed';
status.classList.add('error');
// Put lines back if failed
lineBuffer = [...batch, ...lineBuffer];
}
}
}, 50); // Sync every 50ms for near-instant updates
}

// Listen for new lines every 200ms
function startRealtimeListener() {
let lastCheck = Date.now();

listenInterval = setInterval(async () => {
if (isConnected && !isDrawing) {
try {
// Check for new lines using timestamp filter
const response = await fetch(`${linesRef}?orderBy="timestamp"&startAt=${lastCheck - 1000}`);
const data = await response.json();

if (data) {
const newLines = Object.entries(data)
.map(([id, line]) => ({ ...line, id }))
.filter(line => line.sessionId !== sessionId)
.sort((a, b) => a.timestamp - b.timestamp);

newLines.forEach(line => {
drawLine(line.x1, line.y1, line.x2, line.y2, line.color, line.size);
});
}

lastCheck = Date.now();

// Check for clear signal
const clearResponse = await fetch(clearRef);
const clearData = await clearResponse.json();
if (clearData && clearData.timestamp > (window.lastClearTime || 0)) {
window.lastClearTime = clearData.timestamp;
ctx.clearRect(0, 0, canvas.width, canvas.height);
status.textContent = 'üü¢ Canvas Cleared';
setTimeout(() => status.textContent = 'üü¢ Live', 1000);
}
                        
                        // Check for other users' cursors
                        const cursorsResponse = await fetch(cursorsRef);
                        const cursorsData = await cursorsResponse.json();
                        if (cursorsData) {
                            updateOtherCursors(cursorsData);
                        }
} catch (error) {
console.error('Listener error:', error);
}
}
}, 200); // Check every 200ms for ultra-responsive updates
}

// Color buttons
colors.forEach(color => {
const btn = document.createElement('div');
btn.className = 'color-btn';
btn.style.backgroundColor = color;
if (color === '#FFFFFF') btn.style.border = '2px solid #333';
if (color === currentColor) btn.classList.add('active');
btn.addEventListener('click', () => {
currentColor = color;
document.querySelectorAll('.color-btn').forEach(b => b.classList.remove('active'));
btn.classList.add('active');
});
colorPalette.appendChild(btn);
});

drawBtn.addEventListener('click', () => {
currentTool = 'draw';
drawBtn.classList.add('active');
panBtn.classList.remove('active');
canvas.classList.remove('pan-mode');
});

panBtn.addEventListener('click', () => {
currentTool = 'pan';
panBtn.classList.add('active');
drawBtn.classList.remove('active');
canvas.classList.add('pan-mode');
});

sizeSlider.addEventListener('input', (e) => {
brushSize = parseInt(e.target.value);
sizeValue.textContent = brushSize;
            
            // Visual feedback for large sizes in admin mode
            if (isAdmin && brushSize > 100) {
                sizeValue.style.fontWeight = 'bold';
                sizeValue.style.color = '#e65100';
            } else {
                sizeValue.style.fontWeight = 'normal';
                sizeValue.style.color = 'inherit';
            }
});

function updateTransform() {
canvas.style.transform = `translate(${translateX}px, ${translateY}px) scale(${scale})`;
zoomInfo.textContent = `Zoom: ${Math.round(scale * 100)}%`;
}

function getCanvasCoords(clientX, clientY) {
const rect = canvas.getBoundingClientRect();
return {
x: (clientX - rect.left) / scale,
y: (clientY - rect.top) / scale
};
}

function startDrawing(e) {
if (currentTool === 'draw') {
isDrawing = true;
const coords = getCanvasCoords(e.clientX, e.clientY);
lastX = coords.x;
lastY = coords.y;
currentStroke = [];
                
                // Send cursor position when starting to draw (especially for mobile)
                if (isMobile) {
                    updateCursorPosition(coords.x, coords.y, true);
                }
} else if (currentTool === 'pan') {
isPanning = true;
panStartX = e.clientX - translateX;
panStartY = e.clientY - translateY;
}
}

function draw(e) {
if (currentTool === 'draw' && isDrawing) {
const coords = getCanvasCoords(e.clientX, e.clientY);

// Draw immediately locally
drawLine(lastX, lastY, coords.x, coords.y, currentColor, brushSize);

// Add to buffer for syncing (draws as you draw, not on release)
const line = {
x1: lastX,
y1: lastY,
x2: coords.x,
y2: coords.y,
color: currentColor,
size: brushSize,
timestamp: Date.now(),
sessionId: sessionId
};
lineBuffer.push(line);
currentStroke.push(line);

lastX = coords.x;
lastY = coords.y;
} else if (currentTool === 'pan' && isPanning) {
translateX = e.clientX - panStartX;
translateY = e.clientY - panStartY;
updateTransform();
}
}

function stopDrawing() {
if (isDrawing && currentStroke.length > 0) {
history.push([...currentStroke]);
historyStep = history.length - 1;
currentStroke = [];
updateUndoRedoButtons();
                
                // Hide cursor for mobile users when they stop drawing
                if (isMobile) {
                    updateCursorPosition(0, 0, false);
                }
}
isDrawing = false;
isPanning = false;
}

function drawLine(x1, y1, x2, y2, color, size) {
ctx.strokeStyle = color;
ctx.lineWidth = size;
ctx.lineCap = 'round';
ctx.lineJoin = 'round';
ctx.beginPath();
ctx.moveTo(x1, y1);
ctx.lineTo(x2, y2);
ctx.stroke();
}

function updateUndoRedoButtons() {
undoBtn.disabled = history.length === 0;
redoBtn.disabled = true; // Redo disabled in real-time mode
}

        // Update cursor position to Firebase
        async function updateCursorPosition(x, y, visible) {
            const now = Date.now();
            if (now - lastCursorUpdate < 50 && visible) return; // Throttle to 20 updates/sec
            lastCursorUpdate = now;
            
            if (isConnected) {
                try {
                    await fetch(`${cursorsRef}/${sessionId}.json`, {
                        method: 'PUT',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            x: x,
                            y: y,
                            color: currentColor,
                            visible: visible,
                            isMobile: isMobile,
                            timestamp: now
                        })
                    });
                } catch (error) {
                    console.error('Cursor update error:', error);
                }
            }
        }

        // Update other users' cursors on screen
        function updateOtherCursors(cursorsData) {
            const now = Date.now();
            const activeSessions = new Set();
            
            Object.entries(cursorsData).forEach(([sid, cursor]) => {
                if (sid === sessionId) return; // Skip own cursor
                if (now - cursor.timestamp > 3000) return; // Ignore stale cursors (>3sec old)
                if (!cursor.visible) return; // Skip invisible cursors
                if (cursor.isMobile && !cursor.visible) return; // Mobile users only show when drawing
                
                activeSessions.add(sid);
                
                let cursorEl = userCursors.get(sid);
                if (!cursorEl) {
                    cursorEl = document.createElement('div');
                    cursorEl.className = 'cursor';
                    cursorEl.innerHTML = `<div class="cursor-label">User</div>`;
                    canvas.parentElement.appendChild(cursorEl);
                    userCursors.set(sid, cursorEl);
                }
                
                // Position cursor with zoom and pan
                const screenX = cursor.x * scale + translateX;
                const screenY = cursor.y * scale + translateY;
                
                cursorEl.style.left = screenX + 'px';
                cursorEl.style.top = screenY + 'px';
                cursorEl.style.background = cursor.color;
                cursorEl.style.display = 'block';
            });
            
            // Remove cursors for users who left or stopped drawing
            userCursors.forEach((cursorEl, sid) => {
                if (!activeSessions.has(sid)) {
                    cursorEl.style.display = 'none';
                }
            });
        }

        // Track mouse movement for cursor position (desktop only)
        if (!isMobile) {
            canvas.addEventListener('mousemove', (e) => {
                if (currentTool === 'draw' && !isPanning) {
                    const coords = getCanvasCoords(e.clientX, e.clientY);
                    updateCursorPosition(coords.x, coords.y, true);
                }
            });
        }

function undo() {
if (history.length > 0) {
history.pop();
historyStep = history.length - 1;
redrawFromHistory();
updateUndoRedoButtons();
}
}

function redrawFromHistory() {
ctx.clearRect(0, 0, canvas.width, canvas.height);
history.forEach(stroke => {
stroke.forEach(line => {
drawLine(line.x1, line.y1, line.x2, line.y2, line.color, line.size);
});
});
}

undoBtn.addEventListener('click', undo);

document.addEventListener('keydown', (e) => {
if (e.ctrlKey && e.key === 'z' && !e.shiftKey) {
e.preventDefault();
undo();
}
});

// Zoom
canvas.addEventListener('wheel', (e) => {
e.preventDefault();
const rect = canvas.getBoundingClientRect();
const mouseX = e.clientX - rect.left;
const mouseY = e.clientY - rect.top;
const delta = e.deltaY > 0 ? 0.9 : 1.1;
const newScale = Math.min(Math.max(0.1, scale * delta), 10);
const scaleChange = newScale / scale;
translateX = mouseX - (mouseX - translateX) * scaleChange;
translateY = mouseY - (mouseY - translateY) * scaleChange;
scale = newScale;
updateTransform();
}, { passive: false });

// Touch events
canvas.addEventListener('touchstart', (e) => {
e.preventDefault();
if (e.touches.length === 1 && currentTool === 'draw') {
const touch = e.touches[0];
const coords = getCanvasCoords(touch.clientX, touch.clientY);
isDrawing = true;
lastX = coords.x;
lastY = coords.y;
currentStroke = [];
} else if (e.touches.length === 1 && currentTool === 'pan') {
const touch = e.touches[0];
isPanning = true;
panStartX = touch.clientX - translateX;
panStartY = touch.clientY - translateY;
} else if (e.touches.length === 2) {
isDrawing = false;
isPanning = false;
const touch1 = e.touches[0];
const touch2 = e.touches[1];
initialPinchDistance = Math.hypot(
touch2.clientX - touch1.clientX,
touch2.clientY - touch1.clientY
);
lastScale = scale;
}
}, { passive: false });

canvas.addEventListener('touchmove', (e) => {
e.preventDefault();
if (e.touches.length === 1 && currentTool === 'draw' && isDrawing) {
const touch = e.touches[0];
const coords = getCanvasCoords(touch.clientX, touch.clientY);

drawLine(lastX, lastY, coords.x, coords.y, currentColor, brushSize);

const line = {
x1: lastX,
y1: lastY,
x2: coords.x,
y2: coords.y,
color: currentColor,
size: brushSize,
timestamp: Date.now(),
sessionId: sessionId
};
lineBuffer.push(line);
currentStroke.push(line);

                // Update cursor position while drawing on mobile
                updateCursorPosition(coords.x, coords.y, true);
                
lastX = coords.x;
lastY = coords.y;
} else if (e.touches.length === 1 && currentTool === 'pan' && isPanning) {
const touch = e.touches[0];
translateX = touch.clientX - panStartX;
translateY = touch.clientY - panStartY;
updateTransform();
} else if (e.touches.length === 2) {
const touch1 = e.touches[0];
const touch2 = e.touches[1];
const currentDistance = Math.hypot(
touch2.clientX - touch1.clientX,
touch2.clientY - touch1.clientY
);
const centerX = (touch1.clientX + touch2.clientX) / 2;
const centerY = (touch1.clientY + touch2.clientY) / 2;
const rect = canvas.getBoundingClientRect();
const pointX = centerX - rect.left;
const pointY = centerY - rect.top;
const newScale = Math.min(Math.max(0.1, lastScale * (currentDistance / initialPinchDistance)), 10);
const scaleChange = newScale / scale;
translateX = pointX - (pointX - translateX) * scaleChange;
translateY = pointY - (pointY - translateY) * scaleChange;
scale = newScale;
updateTransform();
}
}, { passive: false });

canvas.addEventListener('touchend', (e) => {
e.preventDefault();
if (e.touches.length === 0) {
if (isDrawing && currentStroke.length > 0) {
history.push([...currentStroke]);
historyStep = history.length - 1;
currentStroke = [];
updateUndoRedoButtons();
                    
                    // Hide cursor when mobile user stops drawing
                    if (isMobile) {
                        updateCursorPosition(0, 0, false);
                    }
}
isDrawing = false;
isPanning = false;
}
}, { passive: false });

canvas.addEventListener('mousedown', startDrawing);
canvas.addEventListener('mousemove', draw);
canvas.addEventListener('mouseup', stopDrawing);
canvas.addEventListener('mouseout', stopDrawing);

clearBtn.addEventListener('click', async () => {
if (confirm('Clear the canvas for everyone? This cannot be undone!')) {
ctx.clearRect(0, 0, canvas.width, canvas.height);
history = [];
historyStep = -1;
updateUndoRedoButtons();

if (isConnected) {
try {
// Delete all lines
await fetch(linesRef, { method: 'DELETE' });

// Send clear signal to all users
await fetch(clearRef, {
method: 'PUT',
headers: { 'Content-Type': 'application/json' },
body: JSON.stringify({ timestamp: Date.now() })
});

window.lastClearTime = Date.now();
lastLineId = 0;
status.textContent = 'üü¢ Cleared for All';
setTimeout(() => status.textContent = 'üü¢ Live', 1500);
} catch (error) {
console.error('Clear error:', error);
status.textContent = '‚ö†Ô∏è Clear Failed';
status.classList.add('error');
}
}
}
});

// Initialize
updateTransform();
updateUndoRedoButtons();
        checkAdminStatus();
initFirebase();
startBatchSync();
</script>
</body>
</html>
