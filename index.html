<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
<title>LAN Drawing Board</title>

<style>
  html, body {
    margin: 0; padding: 0; overflow: hidden;
    font-family: Arial, sans-serif;
    background: #2a2a2a;
    user-select: none;
  }
  #canvasContainer {
    position: absolute;
    top: 0; left: 0; right: 0; bottom: 80px;
    background: #2a2a2a;
    overflow: hidden;
  }
  canvas {
    position: absolute;
    top: 50%;
    left: 50%;
    display: block;
    transform-origin: 0 0;
    image-rendering: auto;
    background: #fff;
    border: 3px solid #000;
    box-shadow: 0 0 20px rgba(0,0,0,0.5);
  }
  #toolbar {
    position: fixed;
    bottom: 0; left: 0; right: 0;
    height: 80px;
    background: #fff;
    border-top: 2px solid #000;
    display: flex;
    justify-content: center;
    align-items: center;
    gap: 20px;
    padding: 6px;
  }
  .toolButton {
    padding: 10px 18px;
    border-radius: 6px;
    border: 2px solid #333;
    cursor: pointer;
    user-select: none;
    background: #f5f5f5;
    font-weight: bold;
  }
  .toolButton:hover {
    background: #e0e0e0;
  }
  .toolButton.active {
    background: #4CAF50;
    color: white;
    border-color: #2e7d32;
  }
  #paletteContainer {
    display: flex;
    gap: 6px;
  }
  .color {
    width: 30px;
    height: 30px;
    border-radius: 4px;
    border: 2px solid #ccc;
    cursor: pointer;
    box-sizing: border-box;
  }
  .color:hover {
    transform: scale(1.1);
  }
  .color.active {
    border-color: #000;
    border-width: 3px;
  }
  #brushSize {
    width: 150px;
  }
  .sizeLabel {
    font-weight: bold;
    font-size: 14px;
  }
</style>
</head>
<body>

<div id="canvasContainer">
  <canvas id="canvas" width="1200" height="800"></canvas>
</div>

<div id="toolbar">
  <div id="paletteContainer"></div>
  <div class="sizeLabel">
    Size:
    <input type="range" id="brushSize" min="1" max="40" value="8">
    <span id="sizeDisplay">8</span>
  </div>

  <div id="pencilBtn" class="toolButton active">‚úèÔ∏è Pencil</div>
  <div id="eraserBtn" class="toolButton">üßπ Eraser</div>
  <div id="panBtn" class="toolButton">üëÜ Pan</div>
  <div id="clearBtn" class="toolButton">üóëÔ∏è Clear</div>
</div>

<script>
/* CONFIG */
const FIREBASE_DB_URL = "https://drawing-ce2f6-default-rtdb.firebaseio.com";

const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");
const brushSizeEl = document.getElementById("brushSize");
const sizeDisplay = document.getElementById("sizeDisplay");
const paletteContainer = document.getElementById("paletteContainer");
let currentTool = "pencil";

const pencilBtn = document.getElementById("pencilBtn");
const eraserBtn = document.getElementById("eraserBtn");
const panBtn = document.getElementById("panBtn");
const clearBtn = document.getElementById("clearBtn");

pencilBtn.onclick = () => switchTool("pencil");
eraserBtn.onclick = () => switchTool("eraser");
panBtn.onclick = () => switchTool("pan");
clearBtn.onclick = () => {
  ctx.fillStyle = "#fff";
  ctx.fillRect(0, 0, canvas.width, canvas.height);
};

brushSizeEl.oninput = () => {
  sizeDisplay.textContent = brushSizeEl.value;
};

function switchTool(t) {
  currentTool = t;
  pencilBtn.classList.toggle("active", t === "pencil");
  eraserBtn.classList.toggle("active", t === "eraser");
  panBtn.classList.toggle("active", t === "pan");
  
  if (t === "pan") {
    canvas.style.cursor = "grab";
  } else if (t === "eraser") {
    canvas.style.cursor = "cell";
  } else {
    canvas.style.cursor = "crosshair";
  }
}

/* PALETTE - 16 ESSENTIAL COLORS */
const colors = [
  "#000000", // Black
  "#FFFFFF", // White
  "#FF0000", // Red
  "#00FF00", // Green
  "#0000FF", // Blue
  "#FFFF00", // Yellow
  "#FF00FF", // Magenta
  "#00FFFF", // Cyan
  "#FF8800", // Orange
  "#8800FF", // Purple
  "#00FF88", // Mint
  "#FF0088", // Pink
  "#888888", // Gray
  "#8B4513", // Brown
  "#FFB6C1", // Light Pink
  "#4169E1"  // Royal Blue
];

let currentColor = colors[0];
function drawPalette() {
  paletteContainer.innerHTML = "";
  colors.forEach(c => {
    const div = document.createElement("div");
    div.className = "color" + (c === currentColor ? " active" : "");
    div.style.backgroundColor = c;
    div.onclick = () => {
      currentColor = c;
      document.querySelectorAll(".color").forEach(el => el.classList.remove("active"));
      div.classList.add("active");
    };
    paletteContainer.appendChild(div);
  });
}
drawPalette();

// Initialize with white background
ctx.fillStyle = "#fff";
ctx.fillRect(0, 0, canvas.width, canvas.height);

/* PAN + ZOOM with proper transform handling */
let scale = 1;
let offsetX = 0;
let offsetY = 0;

function updateTransform() {
  canvas.style.transform = `translate(${offsetX}px, ${offsetY}px) scale(${scale})`;
}

// Center canvas initially
function centerCanvas() {
  offsetX = -canvas.width / 2;
  offsetY = -canvas.height / 2;
  updateTransform();
}
centerCanvas();

// Handle window resize
window.addEventListener('resize', () => {
  centerCanvas();
});

let isPanning = false;
let panStartX = 0, panStartY = 0, lastOffsetX = 0, lastOffsetY = 0;

canvas.addEventListener("mousedown", e => {
  if (currentTool === "pan") {
    isPanning = true;
    panStartX = e.clientX;
    panStartY = e.clientY;
    lastOffsetX = offsetX;
    lastOffsetY = offsetY;
    canvas.style.cursor = "grabbing";
    e.preventDefault();
  }
});

window.addEventListener("mouseup", () => {
  isPanning = false;
  if (currentTool === "pan") canvas.style.cursor = "grab";
});

window.addEventListener("mousemove", e => {
  if (isPanning) {
    offsetX = lastOffsetX + (e.clientX - panStartX);
    offsetY = lastOffsetY + (e.clientY - panStartY);
    updateTransform();
  }
});

canvas.addEventListener("wheel", e => {
  e.preventDefault();
  
  const rect = canvas.getBoundingClientRect();
  const mouseX = e.clientX - rect.left;
  const mouseY = e.clientY - rect.top;

  const factor = e.deltaY > 0 ? 0.9 : 1.1;
  const newScale = Math.min(Math.max(0.2, scale * factor), 8);

  // Adjust offset to zoom towards mouse position
  offsetX = mouseX - (mouseX - offsetX) * (newScale / scale);
  offsetY = mouseY - (mouseY - offsetY) * (newScale / scale);
  scale = newScale;

  updateTransform();
}, { passive: false });

/* DRAWING with smooth curves */
let drawing = false;
let lastX = null;
let lastY = null;

canvas.addEventListener("mousedown", e => {
  if (currentTool !== "pencil" && currentTool !== "eraser") return;
  if (e.button !== 0) return;
  drawing = true;
  isDrawingLocally = true;
  
  const coords = getCanvasCoords(e);
  lastX = coords.x;
  lastY = coords.y;
  
  drawAtCoords(coords.x, coords.y);
  e.preventDefault();
});

window.addEventListener("mouseup", () => {
  drawing = false;
  isDrawingLocally = false;
  lastX = null;
  lastY = null;
});

canvas.addEventListener("mousemove", e => {
  if (drawing && (currentTool === "pencil" || currentTool === "eraser")) {
    const coords = getCanvasCoords(e);
    drawAtCoords(coords.x, coords.y);
  }
});

function getCanvasCoords(e) {
  const rect = canvas.getBoundingClientRect();
  const x = (e.clientX - rect.left) / scale;
  const y = (e.clientY - rect.top) / scale;
  return { x, y };
}

function drawAtCoords(x, y) {
  const size = parseInt(brushSizeEl.value);
  const color = currentTool === "eraser" ? "#ffffff" : currentColor;

  // Clamp to canvas bounds
  const clampedX = Math.max(0, Math.min(canvas.width, x));
  const clampedY = Math.max(0, Math.min(canvas.height, y));

  // Draw smooth line from last position
  if (lastX !== null && lastY !== null) {
    drawSmoothLine(lastX, lastY, clampedX, clampedY, size, color);
  } else {
    drawBrushStroke(clampedX, clampedY, size, color);
    sendStroke(clampedX, clampedY, size, color);
  }
  
  lastX = clampedX;
  lastY = clampedY;
}

function drawSmoothLine(x1, y1, x2, y2, size, color) {
  const dist = Math.hypot(x2 - x1, y2 - y1);
  const steps = Math.max(1, Math.ceil(dist));
  
  ctx.fillStyle = color;
  ctx.lineCap = "round";
  ctx.lineJoin = "round";
  
  // Use circles for smooth curves and send each point
  for (let i = 0; i <= steps; i++) {
    const t = i / steps;
    const x = x1 + (x2 - x1) * t;
    const y = y1 + (y2 - y1) * t;
    
    ctx.beginPath();
    ctx.arc(x, y, size / 2, 0, Math.PI * 2);
    ctx.fill();
    
    // Send individual points for better sync
    if (i % 3 === 0) { // Send every 3rd point to avoid spam
      sendStroke(x, y, size, color);
    }
  }
}

function drawBrushStroke(x, y, size, color) {
  ctx.fillStyle = color;
  ctx.beginPath();
  ctx.arc(x, y, size / 2, 0, Math.PI * 2);
  ctx.fill();
}

/* INSTANT SYNC */
let isDrawingLocally = false;

async function sendStroke(x, y, size, color) {
  try {
    await fetch(`${FIREBASE_DB_URL}/strokes.json`, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ x, y, size, color, time: Date.now() })
    });
  } catch(e) {
    console.log("Sync failed:", e);
  }
}

// Load existing canvas state on startup
async function loadCanvas() {
  try {
    const res = await fetch(`${FIREBASE_DB_URL}/strokes.json?orderBy="time"`);
    const data = await res.json();
    if (data) {
      const strokes = Object.values(data).sort((a, b) => a.time - b.time);
      strokes.forEach(d => {
        drawBrushStroke(d.x, d.y, d.size, d.color);
      });
    }
  } catch(e) {
    console.log("Failed to load canvas:", e);
  }
}

async function startRealtime() {
  let lastTime = Date.now() - 5000; // Start 5 seconds in the past to catch recent strokes
  
  while (true) {
    try {
      const url = `${FIREBASE_DB_URL}/strokes.json?orderBy="time"&startAt=${lastTime}`;
      const res = await fetch(url);
      const data = await res.json();
      
      if (data) {
        const strokes = Object.values(data).sort((a, b) => a.time - b.time);
        strokes.forEach(d => {
          if (d.time > lastTime && !isDrawingLocally) {
            drawBrushStroke(d.x, d.y, d.size, d.color);
          }
          if (d.time > lastTime) {
            lastTime = d.time;
          }
        });
      }
    } catch(e) {
      console.log("Realtime fetch failed:", e);
    }
    await new Promise(r => setTimeout(r, 50));
  }
}

loadCanvas().then(() => {
  startRealtime();
});

// Set initial cursor
canvas.style.cursor = "crosshair";
</script>
</body>
</html>
